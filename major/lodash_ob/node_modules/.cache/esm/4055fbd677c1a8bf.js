let assignMergeValue,cloneBuffer,cloneTypedArray,copyArray,initCloneObject,isArguments,isArrayLikeObject,isBuffer,isObject,isPlainObject,isTypedArray,toPlainObject;_77c‍.x([["default",()=>_77c‍.o]]);_77c‍.w("./assignMergeValue.js",[["default",["assignMergeValue"],function(v){assignMergeValue=v}]]);_77c‍.w("./cloneBuffer.js",[["default",["cloneBuffer"],function(v){cloneBuffer=v}]]);_77c‍.w("./cloneTypedArray.js",[["default",["cloneTypedArray"],function(v){cloneTypedArray=v}]]);_77c‍.w("./copyArray.js",[["default",["copyArray"],function(v){copyArray=v}]]);_77c‍.w("./initCloneObject.js",[["default",["initCloneObject"],function(v){initCloneObject=v}]]);_77c‍.w("../isArguments.js",[["default",["isArguments"],function(v){isArguments=v}]]);_77c‍.w("../isArrayLikeObject.js",[["default",["isArrayLikeObject"],function(v){isArrayLikeObject=v}]]);_77c‍.w("../isBuffer.js",[["default",["isBuffer"],function(v){isBuffer=v}]]);_77c‍.w("../isObject.js",[["default",["isObject"],function(v){isObject=v}]]);_77c‍.w("../isPlainObject.js",[["default",["isPlainObject"],function(v){isPlainObject=v}]]);_77c‍.w("../isTypedArray.js",[["default",["isTypedArray"],function(v){isTypedArray=v}]]);_77c‍.w("../toPlainObject.js",[["default",["toPlainObject"],function(v){toPlainObject=v}]]);












/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  const objValue = object[key]
  const srcValue = source[key]
  const stacked = stack.get(srcValue)

  if (stacked) {
    assignMergeValue(object, key, stacked)
    return
  }
  let newValue = customizer
    ? customizer(objValue, srcValue, `${key}`, object, source, stack)
    : undefined

  let isCommon = newValue === undefined

  if (isCommon) {
    const isArr = Array.isArray(srcValue)
    const isBuff = !isArr && isBuffer(srcValue)
    const isTyped = !isArr && !isBuff && isTypedArray(srcValue)

    newValue = srcValue
    if (isArr || isBuff || isTyped) {
      if (Array.isArray(objValue)) {
        newValue = objValue
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue)
      }
      else if (isBuff) {
        isCommon = false
        newValue = cloneBuffer(srcValue, true)
      }
      else if (isTyped) {
        isCommon = false
        newValue = cloneTypedArray(srcValue, true)
      }
      else {
        newValue = []
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue)
      }
      else if (typeof objValue === 'function' || !isObject(objValue)) {
        newValue = initCloneObject(srcValue)
      }
    }
    else {
      isCommon = false
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue)
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
    stack['delete'](srcValue)
  }
  assignMergeValue(object, key, newValue)
}

_77c‍.d(baseMergeDeep);
